Index: .idea/dcf77.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/dcf77.iml	(revision )
+++ .idea/dcf77.iml	(revision )
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="CPP_MODULE" version="4">
+  <component name="NewModuleRootManager">
+    <content url="file://$MODULE_DIR$" />
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/modules.xml	(revision )
+++ .idea/modules.xml	(revision )
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/dcf77.iml" filepath="$PROJECT_DIR$/.idea/dcf77.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/.name
===================================================================
--- .idea/.name	(revision )
+++ .idea/.name	(revision )
@@ -0,0 +1,1 @@
+dcf77
\ No newline at end of file
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision )
+++ CMakeLists.txt	(revision )
@@ -0,0 +1,10 @@
+cmake_minimum_required(VERSION 3.2)
+project(dcf77)
+
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
+
+set(SOURCE_FILES
+    dcf77.cpp
+    dcf77.h)
+
+add_executable(dcf77 ${SOURCE_FILES})
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision )
+++ .idea/misc.xml	(revision )
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CMakeWorkspace" PROJECT_DIR="C:\Users\Gavin\Projects\Arduino\dcf77" />
+  <component name="ProjectLevelVcsManager" settingsEditedManually="false">
+    <OptionsSetting value="true" id="Add" />
+    <OptionsSetting value="true" id="Remove" />
+    <OptionsSetting value="true" id="Checkout" />
+    <OptionsSetting value="true" id="Update" />
+    <OptionsSetting value="true" id="Status" />
+    <OptionsSetting value="true" id="Edit" />
+    <ConfirmationsSetting value="0" id="Add" />
+    <ConfirmationsSetting value="0" id="Remove" />
+  </component>
+  <component name="ProjectRootManager" version="2" />
+</project>
\ No newline at end of file
Index: dcf77.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>windows-1252
===================================================================
--- dcf77.cpp	(revision 4fbc69d68e33681415769faf8e33ce5d2a62b957)
+++ dcf77.cpp	(revision )
@@ -17,6 +17,59 @@
 //  along with this program. If not, see http://www.gnu.org/licenses/
 
 #include "dcf77.h"
+
+#define OFFSET_MINUTE_1 (21)
+#define OFFSET_MINUTE_2 (22)
+#define OFFSET_MINUTE_4 (23)
+#define OFFSET_MINUTE_8 (24)
+#define OFFSET_MINUTE_10 (25)
+#define OFFSET_MINUTE_20 (26)
+#define OFFSET_MINUTE_40 (27)
+#define OFFSET_MINUTE_PARITY (28)
+#define OFFSET_MINUTE_PROCESS (29)
+
+#define OFFSET_HOUR_1 (29)
+#define OFFSET_HOUR_2 (30)
+#define OFFSET_HOUR_4 (31)
+#define OFFSET_HOUR_8 (32)
+#define OFFSET_HOUR_10 (33)
+#define OFFSET_HOUR_20 (34)
+#define OFFSET_HOUR_PARITY (35)
+#define OFFSET_HOUR_PROCESS (36)
+
+#define OFFSET_DAY_1 (36)
+#define OFFSET_DAY_2 (37)
+#define OFFSET_DAY_4 (38)
+#define OFFSET_DAY_8 (39)
+#define OFFSET_DAY_10 (40)
+#define OFFSET_DAY_20 (41)
+#define OFFSET_DAY_PROCESS (42)
+
+#define OFFSET_WEEKDAY_1 (42)
+#define OFFSET_WEEKDAY_2 (43)
+#define OFFSET_WEEKDAY_4 (44)
+#define OFFSET_WEEKDAY_PROCESS (45)
+
+#define OFFSET_MONTH_1(45)
+#define OFFSET_MONTH_2(46)
+#define OFFSET_MONTH_4(47)
+#define OFFSET_MONTH_8(48)
+#define OFFSET_MONTH_10(49)
+#define OFFSET_MONTH_PROCESS(50)
+
+#define OFFSET_YEAR_1 (50)
+#define OFFSET_YEAR_2 (51)
+#define OFFSET_YEAR_4 (52)
+#define OFFSET_YEAR_8 (53)
+#define OFFSET_YEAR_PROCESS (54)
+
+#define OFFSET_DECADE_1 (54)
+#define OFFSET_DECADE_2 (55)
+#define OFFSET_DECADE_4 (56)
+#define OFFSET_DECADE_8 (57)
+#define OFFSET_DECADE_PROCESS (58)
+
+
 #include <avr/eeprom.h>
 
 namespace Debug {
@@ -692,128 +745,128 @@
             case 20:  // start of time information
                 return long_tick;
 
-            case 21:
+            case OFFSET_MINUTE_1:
                 if (now.undefined_minute_output || now.minute.val > 0x59) { return undefined; }
                 result = now.minute.digit.lo & 0x1; break;
-            case 22:
+            case OFFSET_MINUTE_2:
                 if (now.undefined_minute_output || now.minute.val > 0x59) { return undefined; }
                 result = now.minute.digit.lo & 0x2; break;
-            case 23:
+            case OFFSET_MINUTE_4:
                 if (now.undefined_minute_output || now.minute.val > 0x59) { return undefined; }
                 result = now.minute.digit.lo & 0x4; break;
-            case 24:
+            case OFFSET_MINUTE_8:
                 if (now.undefined_minute_output || now.minute.val > 0x59) { return undefined; }
                 result = now.minute.digit.lo & 0x8; break;
 
-            case 25:
+            case OFFSET_MINUTE_10:
                 if (now.undefined_minute_output || now.minute.val > 0x59) { return undefined; }
                 result = now.minute.digit.hi & 0x1; break;
-            case 26:
+            case OFFSET_MINUTE_20:
                 if (now.undefined_minute_output || now.minute.val > 0x59) { return undefined; }
                 result = now.minute.digit.hi & 0x2; break;
-            case 27:
+            case OFFSET_MINUTE_40:
                 if (now.undefined_minute_output || now.minute.val > 0x59) { return undefined; }
                 result = now.minute.digit.hi & 0x4; break;
 
-            case 28:
+            case OFFSET_MINUTE_PARITY:
                 if (now.undefined_minute_output || now.minute.val > 0x59) { return undefined; }
                 result = parity(now.minute.val); break;
 
 
-            case 29:
+            case OFFSET_HOUR_1:
                 if (now.hour.val > 0x23) { return undefined; }
                 result = now.hour.digit.lo & 0x1; break;
-            case 30:
+            case OFFSET_HOUR_2:
                 if (now.hour.val > 0x23) { return undefined; }
                 result = now.hour.digit.lo & 0x2; break;
-            case 31:
+            case OFFSET_HOUR_4:
                 if (now.hour.val > 0x23) { return undefined; }
                 result = now.hour.digit.lo & 0x4; break;
-            case 32:
+            case OFFSET_HOUR_8:
                 if (now.hour.val > 0x23) { return undefined; }
                 result = now.hour.digit.lo & 0x8; break;
 
-            case 33:
+            case OFFSET_HOUR_10:
                 if (now.hour.val > 0x23) { return undefined; }
                 result = now.hour.digit.hi & 0x1; break;
-            case 34:
+            case OFFSET_HOUR_20:
                 if (now.hour.val > 0x23) { return undefined; }
                 result = now.hour.digit.hi & 0x2; break;
 
-            case 35:
+            case OFFSET_HOUR_PARITY:
                 if (now.hour.val > 0x23) { return undefined; }
                 result = parity(now.hour.val); break;
 
-            case 36:
+            case OFFSET_DAY_1:
                 if (now.day.val > 0x31) { return undefined; }
                 result = now.day.digit.lo & 0x1; break;
-            case 37:
+            case OFFSET_DAY_2:
                 if (now.day.val > 0x31) { return undefined; }
                 result = now.day.digit.lo & 0x2; break;
-            case 38:
+            case OFFSET_DAY_4:
                 if (now.day.val > 0x31) { return undefined; }
                 result = now.day.digit.lo & 0x4; break;
-            case 39:
+            case OFFSET_DAY_8:
                 if (now.day.val > 0x31) { return undefined; }
                 result = now.day.digit.lo & 0x8; break;
 
-            case 40:
+            case OFFSET_DAY_10:
                 if (now.day.val > 0x31) { return undefined; }
                 result = now.day.digit.hi & 0x1; break;
-            case 41:
+            case OFFSET_DAY_20:
                 if (now.day.val > 0x31) { return undefined; }
                 result = now.day.digit.hi & 0x2; break;
 
-            case 42:
+            case OFFSET_WEEKDAY_1:
                 if (now.weekday.val > 0x7) { return undefined; }
                 result = now.weekday.val & 0x1; break;
-            case 43:
+            case OFFSET_WEEKDAY_2:
                 if (now.weekday.val > 0x7) { return undefined; }
                 result = now.weekday.val & 0x2; break;
-            case 44:
+            case OFFSET_WEEKDAY_4:
                 if (now.weekday.val > 0x7) { return undefined; }
                 result = now.weekday.val & 0x4; break;
 
-            case 45:
+            case OFFSET_MONTH_1:
                 if (now.month.val > 0x12) { return undefined; }
                 result = now.month.digit.lo & 0x1; break;
-            case 46:
+            case OFFSET_MONTH_2:
                 if (now.month.val > 0x12) { return undefined; }
                 result = now.month.digit.lo & 0x2; break;
-            case 47:
+            case OFFSET_MONTH_4:
                 if (now.month.val > 0x12) { return undefined; }
                 result = now.month.digit.lo & 0x4; break;
-            case 48:
+            case OFFSET_MONTH_8:
                 if (now.month.val > 0x12) { return undefined; }
                 result = now.month.digit.lo & 0x8; break;
 
-            case 49:
+            case OFFSET_MONTH_10:
                 if (now.month.val > 0x12) { return undefined; }
                 result = now.month.digit.hi & 0x1; break;
 
-            case 50:
+            case OFFSET_YEAR_1:
                 if (now.year.val > 0x99) { return undefined; }
                 result = now.year.digit.lo & 0x1; break;
-            case 51:
+            case OFFSET_YEAR_2:
                 if (now.year.val > 0x99) { return undefined; }
                 result = now.year.digit.lo & 0x2; break;
-            case 52:
+            case OFFSET_YEAR_4:
                 if (now.year.val > 0x99) { return undefined; }
                 result = now.year.digit.lo & 0x4; break;
-            case 53:
+            case OFFSET_YEAR_8:
                 if (now.year.val > 0x99) { return undefined; }
                 result = now.year.digit.lo & 0x8; break;
 
-            case 54:
+            case OFFSET_DECADE_1:
                 if (now.year.val > 0x99) { return undefined; }
                 result = now.year.digit.hi & 0x1; break;
-            case 55:
+            case OFFSET_DECADE_2:
                 if (now.year.val > 0x99) { return undefined; }
                 result = now.year.digit.hi & 0x2; break;
-            case 56:
+            case OFFSET_DECADE_4:
                 if (now.year.val > 0x99) { return undefined; }
                 result = now.year.digit.hi & 0x4; break;
-            case 57:
+            case OFFSET_DECADE_8:
                 if (now.year.val > 0x99) { return undefined; }
                 result = now.year.digit.hi & 0x8; break;
 
@@ -988,13 +1041,13 @@
                 now.undefined_minute_output = false;
                 break;
 
-            case 21: now.minute.val +=      naive_value; break;
-            case 22: now.minute.val +=  0x2*naive_value; break;
-            case 23: now.minute.val +=  0x4*naive_value; break;
-            case 24: now.minute.val +=  0x8*naive_value; break;
-            case 25: now.minute.val += 0x10*naive_value; break;
-            case 26: now.minute.val += 0x20*naive_value; break;
-            case 27: now.minute.val += 0x40*naive_value; break;
+            case OFFSET_MINUTE_1: now.minute.val +=      naive_value; break;
+            case OFFSET_MINUTE_2: now.minute.val +=  0x2*naive_value; break;
+            case OFFSET_MINUTE_4: now.minute.val +=  0x4*naive_value; break;
+            case OFFSET_MINUTE_8: now.minute.val +=  0x8*naive_value; break;
+            case OFFSET_MINUTE_10: now.minute.val += 0x10*naive_value; break;
+            case OFFSET_MINUTE_20: now.minute.val += 0x20*naive_value; break;
+            case OFFSET_MINUTE_40: now.minute.val += 0x40*naive_value; break;
 
             case 28: now.hour.val = 0; break;
             case 29: now.hour.val +=      naive_value; break;
@@ -1149,19 +1202,21 @@
         Hamming::advance_tick(bins);
     }
 
+
+
     void process_tick(const uint8_t current_second, const uint8_t tick_value) {
         using namespace Hamming;
 
         static BCD::bcd_t decade_data;
 
         switch (current_second) {
-            case 54: decade_data.val +=      tick_value; break;
-            case 55: decade_data.val += 0x02*tick_value; break;
-            case 56: decade_data.val += 0x04*tick_value; break;
-            case 57: decade_data.val += 0x08*tick_value;
+            case OFFSET_DECADE_1: decade_data.val +=      tick_value; break;
+            case OFFSET_DECADE_2: decade_data.val += 0x02*tick_value; break;
+            case OFFSET_DECADE_4: decade_data.val += 0x04*tick_value; break;
+            case OFFSET_DECADE_8: decade_data.val += 0x08*tick_value;
             hamming_binning<decade_bins, 4, false>(bins, decade_data); break;
 
-            case 58: compute_max_index(bins);
+            case OFFSET_DECADE_PROCESS: compute_max_index(bins);
             // fall through on purpose
             default: decade_data.val = 0;
         }
@@ -1211,19 +1266,20 @@
         }
     }
 
+
     void process_tick(const uint8_t current_second, const uint8_t tick_value) {
         using namespace Hamming;
 
         static BCD::bcd_t year_data;
 
         switch (current_second) {
-            case 50: year_data.val +=      tick_value; break;
-            case 51: year_data.val +=  0x2*tick_value; break;
-            case 52: year_data.val +=  0x4*tick_value; break;
-            case 53: year_data.val +=  0x8*tick_value;
+            case OFFSET_YEAR_1: year_data.val +=      tick_value; break;
+            case OFFSET_YEAR_2: year_data.val +=  0x2*tick_value; break;
+            case OFFSET_YEAR_4: year_data.val +=  0x4*tick_value; break;
+            case OFFSET_YEAR_8: year_data.val +=  0x8*tick_value;
             hamming_binning<year_bins, 4, false>(bins, year_data); break;
 
-            case 54: compute_max_index(bins);
+            case OFFSET_YEAR_PROCESS: compute_max_index(bins);
             // fall through on purpose
             default: year_data.val = 0;
         }
@@ -1291,20 +1347,21 @@
         Hamming::advance_tick(bins);
     }
 
+
     void process_tick(const uint8_t current_second, const uint8_t tick_value) {
         using namespace Hamming;
 
         static BCD::bcd_t month_data;
 
         switch (current_second) {
-            case 45: month_data.val +=      tick_value; break;
-            case 46: month_data.val +=  0x2*tick_value; break;
-            case 47: month_data.val +=  0x4*tick_value; break;
-            case 48: month_data.val +=  0x8*tick_value; break;
-            case 49: month_data.val += 0x10*tick_value;
+            case OFFSET_MONTH_1: month_data.val +=      tick_value; break;
+            case OFFSET_MONTH_2: month_data.val +=  0x2*tick_value; break;
+            case OFFSET_MONTH_4: month_data.val +=  0x4*tick_value; break;
+            case OFFSET_MONTH_8: month_data.val +=  0x8*tick_value; break;
+            case OFFSET_MONTH_10: month_data.val += 0x10*tick_value;
             hamming_binning<month_bins, 5, false>(bins, month_data); break;
 
-            case 50: compute_max_index(bins);
+            case OFFSET_MONTH_PROCESS: compute_max_index(bins);
             // fall through on purpose
             default: month_data.val = 0;
         }
@@ -1357,11 +1414,11 @@
         static BCD::bcd_t weekday_data;
 
         switch (current_second) {
-            case 42: weekday_data.val +=      tick_value; break;
-            case 43: weekday_data.val +=  0x2*tick_value; break;
-            case 44: weekday_data.val +=  0x4*tick_value;
+            case OFFSET_WEEKDAY_1: weekday_data.val +=      tick_value; break;
+            case OFFSET_WEEKDAY_2: weekday_data.val +=  0x2*tick_value; break;
+            case OFFSET_WEEKDAY_4: weekday_data.val +=  0x4*tick_value;
             hamming_binning<weekday_bins, 3, false>(bins, weekday_data); break;
-            case 45: compute_max_index(bins);
+            case OFFSET_WEEKDAY_PROCESS: compute_max_index(bins);
             // fall through on purpose
             default: weekday_data.val = 0;
         }
@@ -1414,14 +1471,14 @@
         static BCD::bcd_t day_data;
 
         switch (current_second) {
-            case 36: day_data.val +=      tick_value; break;
-            case 37: day_data.val +=  0x2*tick_value; break;
-            case 38: day_data.val +=  0x4*tick_value; break;
-            case 39: day_data.val +=  0x8*tick_value; break;
-            case 40: day_data.val += 0x10*tick_value; break;
-            case 41: day_data.val += 0x20*tick_value;
+            case OFFSET_DAY_1: day_data.val +=      tick_value; break;
+            case OFFSET_DAY_2: day_data.val +=  0x2*tick_value; break;
+            case OFFSET_DAY_4: day_data.val +=  0x4*tick_value; break;
+            case OFFSET_DAY_8: day_data.val +=  0x8*tick_value; break;
+            case OFFSET_DAY_10: day_data.val += 0x10*tick_value; break;
+            case OFFSET_DAY_20: day_data.val += 0x20*tick_value;
             hamming_binning<day_bins, 6, false>(bins, day_data); break;
-            case 42: compute_max_index(bins);
+            case OFFSET_DAY_PROCESS: compute_max_index(bins);
             // fall through on purpose
             default: day_data.val = 0;
         }
@@ -1474,16 +1531,19 @@
         static BCD::bcd_t hour_data;
 
         switch (current_second) {
-            case 29: hour_data.val +=      tick_value; break;
-            case 30: hour_data.val +=  0x2*tick_value; break;
-            case 31: hour_data.val +=  0x4*tick_value; break;
-            case 32: hour_data.val +=  0x8*tick_value; break;
-            case 33: hour_data.val += 0x10*tick_value; break;
-            case 34: hour_data.val += 0x20*tick_value; break;
+            case OFFSET_HOUR_1: hour_data.val +=      tick_value; break;
+            case OFFSET_HOUR_2: hour_data.val +=  0x2*tick_value; break;
+            case OFFSET_HOUR_4: hour_data.val +=  0x4*tick_value; break;
+            case OFFSET_HOUR_8: hour_data.val +=  0x8*tick_value; break;
+            case OFFSET_HOUR_10: hour_data.val += 0x10*tick_value; break;
+            case OFFSET_HOUR_20: hour_data.val += 0x20*tick_value; break;
+                
+                ??
+                
             case 35: hour_data.val += 0x80*tick_value;        // Parity !!!
                     hamming_binning<hour_bins, 7, true>(bins, hour_data); break;
 
-            case 36: compute_max_index(bins);
+            case OFFSET_HOUR_PROCESS: compute_max_index(bins);
             // fall through on purpose
             default: hour_data.val = 0;
         }
@@ -1535,16 +1595,20 @@
         static BCD::bcd_t minute_data;
 
         switch (current_second) {
-            case 21: minute_data.val +=      tick_value; break;
-            case 22: minute_data.val +=  0x2*tick_value; break;
-            case 23: minute_data.val +=  0x4*tick_value; break;
-            case 24: minute_data.val +=  0x8*tick_value; break;
-            case 25: minute_data.val += 0x10*tick_value; break;
-            case 26: minute_data.val += 0x20*tick_value; break;
-            case 27: minute_data.val += 0x40*tick_value; break;
-            case 28: minute_data.val += 0x80*tick_value;        // Parity !!!
+            case OFFSET_MINUTE_1: minute_data.val +=      tick_value; break;
+            case OFFSET_MINUTE_2: minute_data.val +=  0x2*tick_value; break;
+            case OFFSET_MINUTE_4: minute_data.val +=  0x4*tick_value; break;
+            case OFFSET_MINUTE_8: minute_data.val +=  0x8*tick_value; break;
+            case OFFSET_MINUTE_10: minute_data.val += 0x10*tick_value; break;
+            case OFFSET_MINUTE_20: minute_data.val += 0x20*tick_value; break;
+            case OFFSET_MINUTE_40: minute_data.val += 0x40*tick_value; break;
+            case OFFSET_MINUTE_PARITY: minute_data.val += 0x80*tick_value;        // Parity !!!
                     hamming_binning<minute_bins, 8, true>(bins, minute_data); break;
-            case 29: compute_max_index(bins);
+                
+                
+                ???
+                
+            case OFFSET_MINUTE_PROCESS: compute_max_index(bins);
             // fall through on purpose
             default: minute_data.val = 0;
         }
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/vcs.xml	(revision )
+++ .idea/vcs.xml	(revision )
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
